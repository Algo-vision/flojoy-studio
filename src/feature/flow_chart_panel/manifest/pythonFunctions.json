{
  "OBJECT_DETECTION.py": "import traceback\nfrom flojoy import flojoy, DataContainer, JobResultBuilder\nimport numpy as np\n\nfrom utils.object_detection.object_detection import detect_object\n\n\n@flojoy\ndef OBJECT_DETECTION(v, params):\n    try:\n        red_channel = []\n        green_channel = []\n        blue_channel = []\n        alpha_channel = []\n        print(\"Detecting objects...\")\n        r = v[0].r\n        g = v[0].g\n        b = v[0].b\n        a = v[0].a\n        print(\" a here: \", a)\n        if a is not None:\n            nparr = np.stack((r, g, b, a), axis=2)\n        else:\n            nparr = np.stack((r, g, b), axis=2)\n        img_array = detect_object(nparr)\n        if img_array.shape[2] == 4:\n            red_channel = img_array[:, :, 0]\n            green_channel = img_array[:, :, 1]\n            blue_channel = img_array[:, :, 2]\n            alpha_channel = img_array[:, :, 3]\n        else:\n            red_channel = img_array[:, :, 0]\n            green_channel = img_array[:, :, 1]\n            blue_channel = img_array[:, :, 2]\n            alpha_channel = None\n        return DataContainer(\n            type=\"image\",\n            r=red_channel,\n            g=green_channel,\n            b=blue_channel,\n            a=alpha_channel,\n        )\n\n    except Exception:\n        print(traceback.format_exc())\n        raise\n",
  "LABJACKU3.py": "from flojoy import flojoy, DataContainer\n\nimport u3  # Import the library from LabJackPython in order to use our U3-LV device\n\n\n@flojoy\ndef LABJACKU3(dc, params):  # params {nombre de sensor}\n    d = u3.U3()  # Create an instance of U3 class d.configU3()\n    d.configIO(\n        FIOAnalog=255, EIOAnalog=0\n    )  # Config the U3 for daq from temperature sensors\n\n    voltages = []  # Declaration of variable\n    temperatures = []\n    temperatures_celcius = []\n    N = int(params[\"numbers\"])\n\n    for i in range(1, N):  # Loop on the number of sensor you are using\n        voltage = d.getAIN(i - 1)\n        temperature = voltage * 100.0\n        temperature_celcius = (\n            temperature - 32\n        ) / 1.8  # Convert Voltage into temperature in Celcius\n\n        voltages.append(voltage)\n        temperatures.append(temperature)\n        temperatures_celcius.append(temperature_celcius)  # Save measurements in lists\n    return DataContainer(\n        x={\"a\": temperatures, \"b\": temperatures_celcius}, y=temperatures_celcius\n    )\n\n\n@flojoy\ndef LABJACKU3_MOCK(dc, params):  # params {nombre de sensor}\n    print(\"running mock version of LabJackU3, number of sensor is set to 6 by default\")\n\n    voltages = []  # Declaration of variable\n    temperatures = []\n    temperatures_celcius = []\n    N = 6  # Mock Number of sensors\n\n    for i in range(1, N):  # Loop on the number of sensor you are using\n        voltage = 0.6  # Mock Value for the measured voltage\n        temperature = voltage * 100.0\n        temperature_celcius = (\n            temperature - 32\n        ) / 1.8  # Convert Voltage into temperature in Celcius\n        voltages.append(voltage)\n        temperatures.append(temperature)\n        temperatures_celcius.append(temperature_celcius)  # Save measurements in lists\n\n    return DataContainer(\n        x={\"a\": temperatures, \"b\": temperatures_celcius}, y=temperatures_celcius\n    )\n",
  "KEITHLEY2400.py": "import numpy as np\nimport serial\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef KEITHLEY2400(dc, params):  # params {comport, baudrate,timeout}\n    # Serial communication with the instrument configuration\n    ser = serial.Serial()\n\n    # Specific parameters\n\n    ser.port = params[\"comport\"]  # Secify serial port for com\n    ser.baudrate = params[\"baudrate\"]  # Specify Baudrate\n\n    # General parameters\n    ser.bytesize = serial.EIGHTBITS  # Specify Bites number\n    ser.parity = serial.PARITY_NONE  # Specify Parity\n    ser.stopbits = serial.STOPBITS_ONE  # Specify Stop bites\n    ser.timeout = 1\n    # Open Serial Com\n    ser.open()\n\n    # Keithley 2400 Configuration\n    ser.write(b\"*RST\\n\")  # reinitialisation of the instrument\n    ser.write(b\":SOUR:FUNC:MODE VOLT\\n\")  # Sourcing tension\n    ser.write(b':SENS:FUNC \"CURR\"\\n')  # Measuring current\n    ser.write(\n        b\":SENS:CURR:PROT 1.05\\n\"\n    )  # Current protection set at 1.05A : Maximum for keithely 2400\n\n    voltages = dc[0].y\n    currents_neg = []  # measured currents\n\n    for voltage in voltages:\n        ser.write(b\":SOUR:VOLT %f\\n\" % voltage)  # Source Tension (V)\n        ser.write(b\":OUTP ON\\n\")  # Instrument output open\n        ser.write(b\":INIT\\n\")  # Start measuring\n        ser.write(b\":FETC?\\n\")  # Retrieve the measured values\n\n        current_str = ser.readline().decode(\"ascii\").strip()  # Save answers in a string\n        voltage_current_values = current_str.split(\n            \",\"\n        )  # Split the string into measured values (Voltage, Current, Etc)\n        currents_neg.append(\n            -float(voltage_current_values[1])\n        )  # Converts measured currents into float\n\n        ser.write(b\":OUTP OFF\\n\")  # Close output from Instrument\n\n    # Close Serial Communication\n\n    ser.close()\n\n    return DataContainer(x={\"a\": voltages, \"b\": currents_neg}, y=currents_neg)\n\n\n@flojoy\ndef KEITHLEY2400_MOCK(dc, params):  # params {comport, baudrate,timeout}\n    print(\"Running mock version of Keithley2400\")\n\n    voltages = dc[0].y\n    currents_neg = []  # measured currents\n\n    for voltage in voltages:\n        voltage_current_values = (\n            voltages * 0.15\n        )  # Apply a scalar operation on the mock Voltage\n        currents_neg.append(\n            -float(voltage_current_values[1])\n        )  # Converts measured currents into float\n\n    return DataContainer(x={\"a\": voltages, \"b\": currents_neg}, y=currents_neg)\n",
  "SERIAL.py": "from flojoy import flojoy, DataContainer\nfrom time import sleep\nimport serial\nimport numpy as np\nfrom datetime import datetime\nimport plotly.graph_objects as go\n\n\n@flojoy\ndef SERIAL(v, params):\n    \"\"\"\n    Node to take simple time dependent 1d data from an Ardunio,\n    or a similar serial device.\n    For example you can record temperature following this tutorial:\n\n    https://learn.adafruit.com/thermistor/using-a-thermistor\n\n    with Serial.println(steinhart) as the only line printing.\n\n    It is important that the last line Arduino is returning is the\n    data with a new line at the end (i.e. println()).\n\n    The other lines must be returned with print()\n    with print(\",\") between each line.\n\n    For example:\n\n    print(reading0)\n    print(\",\")\n    println(reading1)\n\n    If there is more than one column, the SELECT_ARRAY node must be\n    used after this node.\n\n    params:\n    num_readings: Number of points to record.\n    record_period: Length between two recordings in seconds.\n    BAUD_RATE: Baud rate for the serial device.\n    com_port: COM port of the serial device\n\n    num_readings * record_period is roughly the run length in seconds.\n    \"\"\"\n    print(\"parameters passed to SERIAL: \", params)\n    COM_PORT = params.get(\"com_port\", \"/dev/ttyUSB0\")\n    BAUD = int(params.get(\"BAUD_RATE\", 9600))\n    NUM = int(params.get(\"num_readings\", 100))\n    RECORD_PERIOD = float(params.get(\"record_period\", 1))\n\n    ser = serial.Serial(COM_PORT, timeout=1, baudrate=BAUD)\n    readings = []\n    times = []\n    # The first reading is commonly empty.\n    s = ser.readline().decode()\n\n    for i in range(NUM):\n        ts = datetime.now()\n        s = ser.readline().decode()\n        # Some readings may be empty.\n        if s != \"\":\n            reading = s[:-2].split(\",\")\n            readings.append(reading)\n\n            ts = datetime.now()\n            seconds = float(\n                ts.hour * 3600 + ts.minute * 60 + ts.second + ts.microsecond / 10**6\n            )\n\n            times.append(seconds)\n\n            if len(times) > 0:\n                time1 = seconds - times[i]\n            else:\n                # Estimate execution time.\n                time1 = 0.1\n\n            if time1 < RECORD_PERIOD:\n                sleep(RECORD_PERIOD - time1)\n\n    times = np.array(times)\n    times -= times[0]\n    readings = np.array(readings)\n    readings = readings.astype(\"float64\")\n    # If there are two or more columns return a Plotly figure.\n    if readings.ndim == 2:\n        data = go.Line(x=times, y=readings[:, 0], mode=\"markers\")\n        fig = go.Figure(data=data)\n        return DataContainer(type=\"plotly\", fig=fig, x=times, y=readings)\n    else:\n        return DataContainer(x=times, y=readings)\n\n\n@flojoy\ndef Serial_MOCK(dc, params):\n    print(\"Running mock version of Serial\")\n\n    x = np.linspace(0, 100, 100)\n    y = np.linspace(0, 100, 100)\n\n    return DataContainer(x=x, y=y)\n",
  "PHIDGET22.py": "from flojoy import flojoy, DataContainer\nimport Phidget22\nfrom Phidget22.Phidget import *\nfrom Phidget22.Devices.VoltageRatioInput import *\n\n\ndef onVoltageRatioChange(self, voltageRatio):\n    print(\n        \"VoltageRatio [\" + str(self.getChannel()) + \"]: \" + str(voltageRatio)\n    )  # Declaration of the Event handler, Voltage changement\n\n\n@flojoy\ndef PHIDGET22(dc, params):\n    voltage = []\n    pressions = []\n    N = int(params[\"n_sensors\"])\n\n    for i in range(0, N):\n        voltageRatioInput = (\n            VoltageRatioInput()\n        )  # Creation of an instance of the VoltageRationInput class\n        voltageRatioInput.setChannel(\n            i\n        )  # Set Channel for Communication with the Phidget Interface Kit\n        voltageRatioInput.setOnVoltageRatioChangeHandler(\n            onVoltageRatioChange\n        )  # Assign the handler that will be called when the event occurs\n        voltageRatioInput.openWaitForAttachment(\n            5000\n        )  # Open the Channel after event handler is set\n        volt_i = voltageRatioInput.getVoltageRatio()  # Measure Voltage from the sensor\n        voltage.append(volt_i)  # Add Voltage to the list of measurements\n\n        pression_i = (\n            volt_i - 0.015\n        ) / 0.06  # Example of a Calibration to convert Voltage into pression\n        pressions.append(pression_i)\n\n    return DataContainer(x={\"a\": voltage, \"b\": pressions}, y=pressions)\n\n\n@flojoy\ndef PHIDGET22_MOCK(dc, params):\n    print(\n        \"running mock version of PHIDGET SENSOR, number of sensor is set to 4 by default\"\n    )\n\n    voltage = []\n    pressions = []\n    N = 4\n\n    for i in range(0, N):\n        volt_i = i * 10 + 4  # Scalar operation to modify data\n        voltage.append(volt_i)  # Add Voltage to the list of measurements\n        pression_i = (\n            volt_i - 0.015\n        ) / 0.06  # Example of a Calibration to convert Voltage into pression\n        pressions.append(pression_i)\n\n    return DataContainer(x={\"a\": voltage, \"b\": pressions}, y=pressions)\n",
  "CAMERA.py": "import cv2\nimport os\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef CAMERA(v, params):\n    \"\"\"\n    Take a picture from a connected camera using OpenCV.\n    If no camera is connected, this will load the example image: \"object_detection.png\".\n    Perhaps after testing is finished, an error should be thrown if no camera was detected.\n    \"\"\"\n    print(\"parameters passed to CAMERA: \", params)\n    y = {}\n    camera_test = False  # Value to test if image is the default image.\n\n    try:\n        camera_index = int(params.get(\"camera_ind\", -1))\n        camera = cv2.VideoCapture(\n            camera_index\n        )  # Camera indicator for selection of specific camera\n        test = camera.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)\n        # print('\\n', test, '\\n')  # Print to check if setting the resolution worked.\n        camera.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)\n\n        (\n            return_value,\n            image,\n        ) = camera.read()  # Read camera. Return value can be useful for testing.\n        if image is None:\n            raise cv2.error\n\n        # print(image.shape)\n        camera_test = True  # Camera has been detected.\n        camera.release()  # Release the camera for further use.\n        del camera\n\n    except (\n        cv2.error\n    ) as camera_error:  # Catch error for when a camera isn't detected. Should it throw an error for production?\n        pass\n\n    if not camera_test:\n        print(\"OpenCV cannot read the specified camera.\")\n        print(\"Loading backup image.\")\n        filePath = \"../public/assets/object_detection.png\"  # Load example image instead for testing.\n        # Load the file and put into bytearray.\n        print(\"File to be loaded: \" + filePath)\n        with open(filePath, \"rb\") as fileToBeLoaded:\n            f = fileToBeLoaded.read()\n            # print(type(cv2.imread(filePath)))\n            y = [bytearray(f)]\n            # print(type(f))\n            # print(type(bytearray(f)))\n        fileToBeLoaded.close()\n\n    else:\n        f = cv2.imencode(\".png\", image)[1]  # encode image to pass to next node.\n        y = [bytearray(f)]\n\n    return DataContainer(type=\"file\", y=y, file_type=[\"image\"])\n",
  "FIR.py": "from scipy import signal\nfrom flojoy import flojoy, DataContainer\nimport numpy as np\n\n\n@flojoy\ndef FIR(v, params):\n    \"\"\"Apply a low-pass FIR filter to an input vector. This\n    filter takes a few inputs: the sample_rate (will be passed as a parameter\n    if the target node is not connected), the desired width of the\n    transition to the stop band and the corresponding attentuation, and\n    lastly the cutoff frequency.\"\"\"\n\n    sample_rate = float(params[\"sample_rate\"])  # Hz\n    transition_width = float(params[\"transition_width\"])  # Hz\n    stop_band_attenuation = float(params[\"stop_band_attenuation\"])  # dB\n    cutoff_freq = float(params[\"cutoff_freq\"])  # Hz\n    print(\n        f\"FIR params: {[sample_rate,transition_width,stop_band_attenuation,cutoff_freq]}\"\n    )\n\n    try:\n        times = v[1].y  # v[0].x['i']\n        x = v[0].y  # this is the value of the signal\n    except IndexError:  # nothing input\n        # lets create some default behaviour for testing\n        nsamples = 400\n        times = np.arange(nsamples) / sample_rate\n        test_x = (\n            np.cos(2 * np.pi * 0.5 * times)\n            + 0.2 * np.sin(2 * np.pi * 2.5 * times + 0.1)\n            + 0.2 * np.sin(2 * np.pi * 15.3 * times)\n            + 0.1 * np.sin(2 * np.pi * 16.7 * times + 0.1)\n            + 0.1 * np.sin(2 * np.pi * 23.45 * times + 0.8)\n        )\n        x = test_x\n\n    # first we need to define the nyquist rate ...\n    nyq_rate = sample_rate / 2.0\n    # ... then the transition width relative to this\n    transition_width /= nyq_rate\n\n    # Now compute order and Kaiser param for the fitler\n    N, beta = signal.kaiserord(stop_band_attenuation, transition_width)\n\n    # Now we create the filter with the Kaiser window ...\n    taps = signal.firwin(N, cutoff_freq / nyq_rate, window=(\"kaiser\", beta))\n\n    # ... and then apply it to the signal\n    filtered_x = signal.lfilter(taps, 1.0, x)\n\n    # Now, there are two considerations to be had. Firstly,\n    # there is a phase delay in the signal since we have applied finite\n    # taps ...\n    phase_delay = 0.5 * (N - 1) / sample_rate\n    # ... and furthermore, the first N-1 samples are 'corrupted' in\n    # the sense that the filter 'sacrifies' them by the imposition\n    # of the initial conditions.\n    times = times[N - 1 :] - phase_delay\n    filtered_x = filtered_x[N - 1 :]\n\n    return DataContainer(x=times, y=filtered_x)\n",
  "PID.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\nfrom node_sdk.small_memory import SmallMemory\n\nmemory_key = \"pid-info\"\n\n\n@flojoy\ndef PID(v, params):\n    # First let's get the parameters that won't change\n    Kp = float(params[\"Kp\"])\n    Ki = float(params[\"Ki\"])\n    Kd = float(params[\"Kd\"])\n    node_id = params.get(\"node_id\", 0)\n    # Now we need some memory! We need to keep track of the running\n    # integral value of the inputs (regulation errors), as well as\n    # the previous 3 values of the regulation error\n    data = SmallMemory().read_memory(node_id, memory_key)\n    if type(data) == dict:\n        initialize = True\n    elif type(data) == np.ndarray:\n        initialize = False\n    else:\n        raise TypeError(\"Issue reading memory from REDIS.\")\n    integral = 0 if initialize else data[0]\n    regulation_error_primes = np.zeros((3, 1)) if initialize else data[1:]\n    print(f\"Recovered data: {data}\")\n\n    regulation_error = v[0].y[\n        -1\n    ]  # constant node makes long list of items; just need the value so take last element\n    integral += 0.5 * Ki * (regulation_error + regulation_error_primes[0])\n    output_signal = (\n        Kp * regulation_error\n        + integral\n        + 0.1667\n        * Kd\n        * (\n            regulation_error\n            - regulation_error_primes[2]\n            + 3.0 * (regulation_error_primes[0] - regulation_error_primes[1])\n        )\n    )\n    regulation_error_primes[2] = regulation_error_primes[1]\n    regulation_error_primes[1] = regulation_error_primes[0]\n    regulation_error_primes[0] = regulation_error\n\n    # Now write to memory ...\n    SmallMemory().write_to_memory(\n        node_id, memory_key, np.append(integral, regulation_error_primes)\n    )\n    print(regulation_error, output_signal)\n    # ... and return the result\n    return DataContainer(x=v[0].y, y=np.ones_like(v[0].y) * output_signal)\n",
  "SAVGOL.py": "import scipy\nfrom flojoy import flojoy, DataContainer\nimport warnings\n\n\n@flojoy\ndef SAVGOL(v, params):\n    \"\"\"Apply a Savitzky-Golay filter to an input vector.\n    The default behaviour is implementing a 3-point moving average of the data.\"\"\"\n    print(\"Savgol inputs:\", v)\n    signal = v[0].y\n    window_length = int(params[\"wlen\"])\n    poly_order = int(params[\"porder\"])\n    if poly_order >= window_length:\n        warnings.warn(\n            \"Polynomial order is greater than the window size. Using p=w-1...\"\n        )\n        poly_order = window_length - 1\n    filtered = scipy.signal.savgol_filter(signal, window_length, poly_order)\n    return DataContainer(x=signal, y=filtered)\n",
  "BUTTER.py": "from scipy import signal\nimport numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef BUTTER(v, params):\n    \"\"\"Apply a butterworth filter to an input vector\"\"\"\n\n    print(\"Butterworth inputs:\", v)\n\n    sig = v[0].y\n\n    sos = signal.butter(10, 15, \"hp\", fs=1000, output=\"sos\")\n    filtered = signal.sosfilt(sos, sig)\n\n    return DataContainer(x=sig, y=filtered)\n",
  "SELECT_ARRAY.py": "from flojoy import flojoy, DataContainer\nimport numpy as np\n\n\n@flojoy\ndef SELECT_ARRAY(v, params):\n    \"\"\"\n    Node to convert an input array with multiple columns\n    to the selected ordered pair.\n\n    For example, the SERIAL node can output x=time,\n    y1=temperature, y2=pressure.\n    This node will select one of temperature and pressure columns to output.\n\n    The x axis will be return unchanged.\n    \"\"\"\n    print(\"parameters passed to SELECT_ARRAY: \", params)\n    # Index of the selected column.\n    COL = int(params.get(\"column\", 0))\n\n    # Check for numpy type. Return unchanged data if not.\n    if isinstance(v[0].y, np.ndarray):\n        x = v[0].x\n        y = v[0].y[:, int(COL)]\n\n        return DataContainer(x=x, y=y)\n\n    else:\n        return v[0]\n",
  "SUBTRACT.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef SUBTRACT(v, params):\n    \"\"\"Subtract 2 input vectors and return the result\"\"\"\n    # print(' v in add node: ', v)\n    a = [0]\n    b = [0]\n\n    if len(v) == 2:\n        a = v[0].y\n        b = v[1][\"y\"]\n\n    y = np.subtract(a, b)\n\n    return DataContainer(x={\"a\": a, \"b\": b}, y=y)\n",
  "ADD.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef ADD(v, params):\n    \"\"\"Add 2 input vectors and return the result\"\"\"\n    # print(' v in add node: ', v)\n    a = [0]\n    b = [0]\n\n    if len(v) == 2:\n        a = v[0].y\n        b = v[1][\"y\"]\n\n    y = np.add(a, b)\n\n    return DataContainer(x={\"a\": a, \"b\": b}, y=y)\n",
  "MULTIPLY.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef MULTIPLY(v, params):\n    \"\"\"Takes 2 input vectors, multiplies them, and returns the result\"\"\"\n    a = v[0].y\n    b = v[1].y\n    y = np.multiply(a, b)\n    return DataContainer(x={\"a\": a, \"b\": b}, y=y)\n",
  "ABS.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef ABS(v, params):\n    \"\"\"Returns abolute value\"\"\"\n    return DataContainer(x=v[0].y, y=np.abs(v[0].y))\n",
  "INVERT.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef INVERT(v, params):\n    \"\"\"Takes 2 inputs, one matrix and one rcond if not square matrix.\n    Inverts them (or pseudo invert) and returns the result.\n    If the entered value is a scalar it returns the multiplciative\n    inverse 1/x\"\"\"\n    print(f\"INVERT params: {params}\")\n    a = np.eye(3)\n    b = float(params[\"rcond\"])\n\n    if v.__len__ > 0:\n        if (\n            v[0].type == \"ordered_pair\"\n        ):  # v[0] is a DataContainer object with type attribute\n            print(\"Performing simple inversion\")\n            a = v[0].y  # scalar valued\n            return DataContainer(x=a, y=1 / a)\n        elif v[0].type == \"matrix\":\n            a = v[0].m\n            if not a.shape[0] == a.shape[1]:\n                print(\"Not square matrix! Using pseudoinversion...\")\n                assert (\n                    type(b) == float\n                ), \"Need scalar value to compare SVDs for pseudoinversion\"\n                retval = np.linalg.pinv(a, rcond=b, hermitian=False)\n            else:\n                try:\n                    retval = np.linalg.inv(a)\n                except np.linalg.LinAlgError:\n                    raise ValueError(\"Inversion failed! Singular matrix returned...\")\n            return DataContainer(type=\"matrix\", m=retval)\n        else:\n            raise ValueError(\"Incorrect input DataContainer type.\")\n    else:\n        return DataContainer(type=\"matrix\", m=np.eye(3))\n",
  "MATMUL.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef MATMUL(v, params):\n    \"\"\"Takes 2 input matrices, multiplies them, and returns the result\"\"\"\n    a = np.eye(3)\n    b = np.eye(3)\n    if len(v) == 2:\n        a = v[0].y\n        b = v[1][\"y\"]\n    return DataContainer(type=\"matrix\", m=np.matmul(a, b))\n",
  "END.py": "from flojoy import flojoy, JobResultBuilder\n\n\n@flojoy\ndef END(v, params):\n    inputs = v if len(v) > 0 else []\n    return JobResultBuilder().from_inputs(inputs).flow_to_nodes([]).build()\n",
  "GOTO.py": "from flojoy import JobResultBuilder, flojoy\n\n\n@flojoy\ndef GOTO(v, params):\n    goto_node_id = params.get(\"goto_node_id\", None)\n    next_nodes = [goto_node_id] if goto_node_id is not None else []\n\n    return JobResultBuilder().from_inputs(v).flow_to_nodes(next_nodes).build()\n",
  "LOOP.py": "import json\n\nfrom node_sdk.small_memory import SmallMemory\n\nfrom flojoy import JobResultBuilder, flojoy\n\nmemory_key = \"loop-info\"\n\n\nclass LoopData:\n    def __init__(\n        self, node_id, num_loops=-1, current_iteration=0, is_finished=False\n    ) -> None:\n        self.node_id = node_id\n        self.num_loops = int(num_loops)\n        self.current_iteration = int(current_iteration)\n        self.is_finished = bool(is_finished)\n\n    def restart(self):\n        self.current_iteration = 0\n        self.is_finished = False\n\n    def step(self):\n        self.current_iteration += 1\n        if self.current_iteration > self.num_loops:\n            self.is_finished = True\n\n    def get_data(self):\n        return {\n            \"node_id\": self.node_id,\n            \"num_loops\": self.num_loops,\n            \"current_iteration\": self.current_iteration,\n            \"is_finished\": self.is_finished,\n        }\n\n    @staticmethod\n    def from_data(node_id, data):\n        loop_data = LoopData(\n            node_id,\n            num_loops=data.get(\"num_loops\", -1),\n            current_iteration=data.get(\"current_iteration\", 0),\n            is_finished=data.get(\"is_finished\", False),\n        )\n        return loop_data\n\n    def print(self, prefix=\"\"):\n        print(f\"{prefix}loop Data:\", json.dumps(self.get_data(), indent=2))\n\n\n@flojoy\ndef LOOP(v, params):\n    num_loops = params.get(\"num_loops\", 0)\n    node_id = params.get(\"node_id\", 0)\n\n    print(\"\\n\\nstart loop:\", node_id)\n\n    # infinite loop\n    if num_loops == -1:\n        print(\"infinite loop\")\n        return build_result(inputs=v, is_loop_finished=False)\n\n    loop_data: LoopData = load_loop_data(node_id, num_loops)\n    loop_data.print(\"at start \")\n\n    # loop was previously finished, but now re-executing, so restart\n    if loop_data.is_finished:\n        loop_data.restart()\n    else:\n        loop_data.step()\n\n    if not loop_data.is_finished:\n        store_loop_data(node_id, loop_data)\n    else:\n        print(\"finished loop\")\n        delete_loop_data(node_id)\n\n    print(\"end loop\\n\\n\")\n\n    return build_result(v, loop_data.is_finished)\n\n\ndef load_loop_data(node_id, default_num_loops) -> LoopData:\n    data = SmallMemory().read_memory(node_id, memory_key)\n    loop_data = LoopData.from_data(\n        node_id=node_id, data={\"num_loops\": default_num_loops, **data}\n    )\n    return loop_data\n\n\ndef store_loop_data(node_id, loop_data: LoopData):\n    SmallMemory().write_to_memory(node_id, memory_key, loop_data.get_data())\n    loop_data.print(\"store \")\n\n\ndef delete_loop_data(node_id):\n    SmallMemory().delete_object(node_id, memory_key)\n    print(\"delete loop data\")\n\n\ndef build_result(inputs, is_loop_finished):\n    return (\n        JobResultBuilder()\n        .from_inputs(inputs)\n        .flow_by_flag(\n            flag=is_loop_finished,\n            directionsWhenFalse=[\"body\"],\n            directionsWhenTrue=[\"end\"],\n        )\n        .build()\n    )\n",
  "TIMER.py": "from flojoy import flojoy, DataContainer, JobResultBuilder\nimport time\n\n\n@flojoy\ndef TIMER(v, params):\n    print(\"executing timer\")\n\n    seconds = int(params[\"sleep_time\"])\n    time.sleep(seconds)\n\n    return JobResultBuilder().from_inputs(v).build()\n",
  "CONDITIONAL.py": "from flojoy import flojoy, DataContainer, JobResultBuilder\nfrom utils.utils import compare_values\n\n\n@flojoy\ndef CONDITIONAL(v, params):\n    operator = params[\"operator_type\"]\n\n    x = v[1].y\n    y = v[0].y\n    bool_ = compare_values(x[0], y[0], operator)\n\n    data = None\n    if operator in [\"<=\", \"<\"]:\n        if not bool_:\n            data = DataContainer(x=v[0].x, y=y)\n        else:\n            data = DataContainer(x=v[1].x, y=x)\n    else:\n        if bool_:\n            data = DataContainer(x=v[0].x, y=y)\n        else:\n            data = DataContainer(x=v[1].x, y=x)\n\n    next_direction = str(bool_).lower()\n\n    return (\n        JobResultBuilder().from_data(data).flow_to_directions([next_direction]).build()\n    )\n",
  "shapiro.py": "from flojoy import DataContainer, flojoy\nimport scipy.stats\n\n@flojoy\ndef SHAPIRO(dc, params):\n\t'''\n\t\tPerform the Shapiro-Wilk test for normality.\n\t\t\n\t\tThe Shapiro-Wilk test tests the null hypothesis that the\n\t\tdata was drawn from a normal distribution.\n\t\t\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\tThe parameters of the function in this Flojoy wrapper are given below.\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\n\tParameters\n\t----------\n\tx : array_like\n\t\tArray of sample data.\n\t\t\t'''\n\treturn DataContainer(\n\t\tx=dc[0].y,\n\t\ty=scipy.stats.shapiro(\n\t\t\tx=dc[0].y,\n\t\t\t)\n\t)\n\n",
  "binom_test.py": "from flojoy import DataContainer, flojoy\nimport scipy.stats\n\n@flojoy\ndef BINOM_TEST(dc, params):\n\t'''\n\t\tPerform a test that the probability of success is p.\n\t\t\n\tNote: `binom_test` is deprecated; it is recommended that `binomtest`\n\t\tbe used instead.\n\t\t\n\t\tThis is an exact, two-sided test of the null hypothesis\n\t\tthat the probability of success in a Bernoulli experiment\n\t\tis `p`.\n\t\t\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\tThe parameters of the function in this Flojoy wrapper are given below.\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\n\tParameters\n\t----------\n\tx : int or array_like\n\t\tThe number of successes, or if x has length 2, it is the\n\t\tnumber of successes and the number of failures.\n\tn : int\n\t\tThe number of trials.  This is ignored if x gives both the\n\t\tnumber of successes and failures.\n\tp : float, optional\n\t\tThe hypothesized probability of success.  ``0 <= p <= 1``. The\n\t\tdefault value is ``p = 0.5``.\n\talternative : {'two-sided', 'greater', 'less'}, optional\n\t\tIndicates the alternative hypothesis. The default value is\n\t\t'two-sided'.\n\t\t\t'''\n\treturn DataContainer(\n\t\tx=dc[0].y,\n\t\ty=scipy.stats.binom_test(\n\t\t\tx=dc[0].y,\n\t\t\tn=(int(params['n']) if params['n'] != '' else None),\n\t\t\tp=(float(params['p']) if params['p'] != '' else None),\n\t\t\talternative=(str(params['alternative']) if params['alternative'] != '' else None),\n\t\t)\n\t)\n\n",
  "kstatvar.py": "from flojoy import DataContainer, flojoy\nimport scipy.stats\n\n@flojoy\ndef KSTATVAR(dc, params):\n\t'''\n\t\t\n\t\t\n\t\t\n\t\tReturn an unbiased estimator of the variance of the k-statistic.\n\t\t\n\t\tSee `kstat` for more details of the k-statistic.\n\t\t\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\tThe parameters of the function in this Flojoy wrapper are given below.\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\n\tParameters\n\t----------\n\tdata : array_like\n\t\tInput array. Note that n-D input gets flattened.\n\tn : int, {1, 2}, optional\n\t\tDefault is equal to 2.\n\taxis : int or None, default: None\n\t\tIf an int, the axis of the input along which to compute the statistic.\n\t\tThe statistic of each axis-slice (e.g. row) of the input will appear in a\n\t\tcorresponding element of the output.\n\t\tIf ``None``, the input will be raveled before computing the statistic.\n\tnan_policy : {'propagate', 'omit', 'raise'}\n\t\tDefines how to handle input NaNs.\n\t\t\n\t- ``propagate``: if a NaN is present in the axis slice (e.g. row) along\n\t\twhich the  statistic is computed, the corresponding entry of the output\n\t\twill be NaN.\n\t- ``omit``: NaNs will be omitted when performing the calculation.\n\t\tIf insufficient data remains in the axis slice along which the\n\t\tstatistic is computed, the corresponding entry of the output will be\n\t\tNaN.\n\t- ``raise``: if a NaN is present, a ``ValueError`` will be raised.\n\tkeepdims : bool, default: False\n\t\tIf this is set to True, the axes which are reduced are left\n\t\tin the result as dimensions with size one. With this option,\n\t\tthe result will broadcast correctly against the input array.\n\t\t\t'''\n\treturn DataContainer(\n\t\tx=dc[0].y,\n\t\ty=scipy.stats.kstatvar(\n\t\t\tdata=dc[0].y,\n\t\t\tn=(int(params['n']) if params['n'] != '' else None),\n\t\t\taxis=(int or None(params['axis']) if params['axis'] != '' else None),\n\t\t\tnan_policy=(str(params['nan_policy']) if params['nan_policy'] != '' else None),\n\t\t\tkeepdims=(bool(params['keepdims']) if params['keepdims'] != '' else None),\n\t\t)\n\t)\n\n",
  "jarque_bera.py": "from flojoy import DataContainer, flojoy\nimport scipy.stats\n\n@flojoy\ndef JARQUE_BERA(dc, params):\n\t'''\n\t\tPerform the Jarque-Bera goodness of fit test on sample data.\n\t\t\n\t\tThe Jarque-Bera test tests whether the sample data has the skewness and\n\t\tkurtosis matching a normal distribution.\n\t\t\n\t\tNote that this test only works for a large enough number of data samples\n\t\t(>2000) as the test statistic asymptotically has a Chi-squared distribution\n\t\twith 2 degrees of freedom.\n\t\t\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\tThe parameters of the function in this Flojoy wrapper are given below.\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\n\tParameters\n\t----------\n\tx : array_like\n\t\tObservations of a random variable.\n\t\t\t'''\n\treturn DataContainer(\n\t\tx=dc[0].y,\n\t\ty=scipy.stats.jarque_bera(\n\t\t\tx=dc[0].y,\n\t\t\t)\n\t)\n\n",
  "mvsdist.py": "from flojoy import DataContainer, flojoy\nimport scipy.stats\n\n@flojoy\ndef MVSDIST(dc, params):\n\t'''\n\t\t\n\t\t'Frozen' distributions for mean, variance, and standard deviation of data.\n\t\t\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\tThe parameters of the function in this Flojoy wrapper are given below.\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\n\tParameters\n\t----------\n\tdata : array_like\n\t\tInput array. Converted to 1-D using ravel.\n\t\tRequires 2 or more data-points.\n\t\t\t'''\n\treturn DataContainer(\n\t\tx=dc[0].y,\n\t\ty=scipy.stats.mvsdist(\n\t\t\tdata=dc[0].y,\n\t\t\t)\n\t)\n\n",
  "anderson.py": "from flojoy import DataContainer, flojoy\nimport scipy.stats\n\n@flojoy\ndef ANDERSON(dc, params):\n\t'''\n\t\tAnderson-Darling test for data coming from a particular distribution.\n\t\t\n\t\tThe Anderson-Darling test tests the null hypothesis that a sample is\n\t\tdrawn from a population that follows a particular distribution.\n\t\tFor the Anderson-Darling test, the critical values depend on\n\t\twhich distribution is being tested against.  This function works\n\t\tfor normal, exponential, logistic, or Gumbel (Extreme Value\n\t\tType I) distributions.\n\t\t\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\tThe parameters of the function in this Flojoy wrapper are given below.\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\n\tParameters\n\t----------\n\tx : array_like\n\t\tArray of sample data.\n\tdist : {'norm', 'expon', 'logistic', 'gumbel', 'gumbel_l', 'gumbel_r', 'extreme1'}, optional\n\t\tThe type of distribution to test against.  The default is 'norm'.\n\t\tThe names 'extreme1', 'gumbel_l' and 'gumbel' are synonyms for the\n\t\tsame distribution.\n\t\t\t'''\n\treturn DataContainer(\n\t\tx=dc[0].y,\n\t\ty=scipy.stats.anderson(\n\t\t\tx=dc[0].y,\n\t\t\tdist=(str(params['dist']) if params['dist'] != '' else None),\n\t\t)\n\t)\n\n",
  "yeojohnson.py": "from flojoy import DataContainer, flojoy\nimport scipy.stats\n\n@flojoy\ndef YEOJOHNSON(dc, params):\n\t'''\n\t\tReturn a dataset transformed by a Yeo-Johnson power transformation.\n\t\t\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\tThe parameters of the function in this Flojoy wrapper are given below.\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\n\tParameters\n\t----------\n\tx : ndarray\n\t\tInput array.  Should be 1-dimensional.\n\tlmbda : float, optional\n\t\tIf ``lmbda`` is ``None``, find the lambda that maximizes the\n\t\tlog-likelihood function and return it as the second output argument.\n\t\tOtherwise the transformation is done for the given value.\n\t\t\t'''\n\treturn DataContainer(\n\t\tx=dc[0].y,\n\t\ty=scipy.stats.yeojohnson(\n\t\t\tx=dc[0].y,\n\t\t\tlmbda=(float(params['lmbda']) if params['lmbda'] != '' else None),\n\t\t)\n\t)\n\n",
  "bayes_mvs.py": "from flojoy import DataContainer, flojoy\nimport scipy.stats\n\n@flojoy\ndef BAYES_MVS(dc, params):\n\t'''\n\t\t\n\t\tBayesian confidence intervals for the mean, var, and std.\n\t\t\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\tThe parameters of the function in this Flojoy wrapper are given below.\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\n\tParameters\n\t----------\n\tdata : array_like\n\t\tInput data, if multi-dimensional it is flattened to 1-D by `bayes_mvs`.\n\t\tRequires 2 or more data points.\n\talpha : float, optional\n\t\tProbability that the returned confidence interval contains\n\t\tthe true parameter.\n\t\t\t'''\n\treturn DataContainer(\n\t\tx=dc[0].y,\n\t\ty=scipy.stats.bayes_mvs(\n\t\t\tdata=dc[0].y,\n\t\t\talpha=(float(params['alpha']) if params['alpha'] != '' else None),\n\t\t)\n\t)\n\n",
  "kstat.py": "from flojoy import DataContainer, flojoy\nimport scipy.stats\n\n@flojoy\ndef KSTAT(dc, params):\n\t'''\n\t\t\n\t\t\n\t\t\n\t\tReturn the nth k-statistic (1<=n<=4 so far).\n\t\t\n\t\tThe nth k-statistic k_n is the unique symmetric unbiased estimator of the\n\t\tnth cumulant kappa_n.\n\t\t\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\tThe parameters of the function in this Flojoy wrapper are given below.\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\n\tParameters\n\t----------\n\tdata : array_like\n\t\tInput array. Note that n-D input gets flattened.\n\tn : int, {1, 2, 3, 4}, optional\n\t\tDefault is equal to 2.\n\taxis : int or None, default: None\n\t\tIf an int, the axis of the input along which to compute the statistic.\n\t\tThe statistic of each axis-slice (e.g. row) of the input will appear in a\n\t\tcorresponding element of the output.\n\t\tIf ``None``, the input will be raveled before computing the statistic.\n\tnan_policy : {'propagate', 'omit', 'raise'}\n\t\tDefines how to handle input NaNs.\n\t\t\n\t- ``propagate``: if a NaN is present in the axis slice (e.g. row) along\n\t\twhich the  statistic is computed, the corresponding entry of the output\n\t\twill be NaN.\n\t- ``omit``: NaNs will be omitted when performing the calculation.\n\t\tIf insufficient data remains in the axis slice along which the\n\t\tstatistic is computed, the corresponding entry of the output will be\n\t\tNaN.\n\t- ``raise``: if a NaN is present, a ``ValueError`` will be raised.\n\tkeepdims : bool, default: False\n\t\tIf this is set to True, the axes which are reduced are left\n\t\tin the result as dimensions with size one. With this option,\n\t\tthe result will broadcast correctly against the input array.\n\t\t\t'''\n\treturn DataContainer(\n\t\tx=dc[0].y,\n\t\ty=scipy.stats.kstat(\n\t\t\tdata=dc[0].y,\n\t\t\tn=(int(params['n']) if params['n'] != '' else None),\n\t\t\taxis=(int or None(params['axis']) if params['axis'] != '' else None),\n\t\t\tnan_policy=(str(params['nan_policy']) if params['nan_policy'] != '' else None),\n\t\t\tkeepdims=(bool(params['keepdims']) if params['keepdims'] != '' else None),\n\t\t)\n\t)\n\n",
  "gauss_spline.py": "from flojoy import DataContainer, flojoy\nimport scipy.signal\n\n@flojoy\ndef GAUSS_SPLINE(dc, params):\n\t'''\n\t\tGaussian approximation to B-spline basis function of order n.\n\t\t\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\tThe parameters of the function in this Flojoy wrapper are given below.\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\n\tParameters\n\t----------\n\tx : array_like\n\t\ta knot vector\n\tn : int\n\t\tThe order of the spline. Must be non-negative, i.e., n >= 0\n\t\t\t'''\n\treturn DataContainer(\n\t\tx=dc[0].y,\n\t\ty=scipy.signal.gauss_spline(\n\t\t\tx=dc[0].y,\n\t\t\tn=(int(params['n']) if params['n'] != '' else None),\n\t\t)\n\t)\n\n",
  "periodogram.py": "from flojoy import DataContainer, flojoy\nimport scipy.signal\n\n@flojoy\ndef PERIODOGRAM(dc, params):\n\t'''\n\t\t\n\t\tEstimate power spectral density using a periodogram.\n\t\t\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\tThe parameters of the function in this Flojoy wrapper are given below.\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\n\tParameters\n\t----------\n\tx : array_like\n\t\tTime series of measurement values\n\tfs : float, optional\n\t\tSampling frequency of the `x` time series. Defaults to 1.0.\n\twindow : str or tuple or array_like, optional\n\t\tDesired window to use. If `window` is a string or tuple, it is\n\t\tpassed to `get_window` to generate the window values, which are\n\t\tDFT-even by default. See `get_window` for a list of windows and\n\t\trequired parameters. If `window` is array_like it will be used\n\t\tdirectly as the window and its length must be nperseg. Defaults\n\t\tto 'boxcar'.\n\tnfft : int, optional\n\t\tLength of the FFT used. If `None` the length of `x` will be\n\t\tused.\n\tdetrend : str or function or `False`, optional\n\t\tSpecifies how to detrend each segment. If `detrend` is a\n\t\tstring, it is passed as the `type` argument to the `detrend`\n\t\tfunction. If it is a function, it takes a segment and returns a\n\t\tdetrended segment. If `detrend` is `False`, no detrending is\n\t\tdone. Defaults to 'constant'.\n\treturn_onesided : bool, optional\n\t\tIf `True`, return a one-sided spectrum for real data. If\n\t\t`False` return a two-sided spectrum. Defaults to `True`, but for\n\t\tcomplex data, a two-sided spectrum is always returned.\n\tscaling : { 'density', 'spectrum' }, optional\n\t\tSelects between computing the power spectral density ('density')\n\t\twhere `Pxx` has units of V**2/Hz and computing the power\n\t\tspectrum ('spectrum') where `Pxx` has units of V**2, if `x`\n\t\tis measured in V and `fs` is measured in Hz. Defaults to\n\t\t'density'\n\taxis : int, optional\n\t\tAxis along which the periodogram is computed; the default is\n\t\tover the last axis (i.e. ``axis=-1``).\n\t\t\t'''\n\treturn DataContainer(\n\t\tx=dc[0].y,\n\t\ty=scipy.signal.periodogram(\n\t\t\tx=dc[0].y,\n\t\t\tfs=(float(params['fs']) if params['fs'] != '' else None),\n\t\t\twindow=(str(params['window']) if params['window'] != '' else None),\n\t\t\tnfft=(int(params['nfft']) if params['nfft'] != '' else None),\n\t\t\tdetrend=(str(params['detrend']) if params['detrend'] != '' else None),\n\t\t\treturn_onesided=(bool(params['return_onesided']) if params['return_onesided'] != '' else None),\n\t\t\tscaling=(str(params['scaling']) if params['scaling'] != '' else None),\n\t\t\taxis=(int(params['axis']) if params['axis'] != '' else None),\n\t\t)\n\t)\n\n",
  "bspline.py": "from flojoy import DataContainer, flojoy\nimport scipy.signal\n\n@flojoy\ndef BSPLINE(dc, params):\n\t'''\n\t\tB-spline basis function of order n.\n\t\t\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\tThe parameters of the function in this Flojoy wrapper are given below.\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\n\tParameters\n\t----------\n\tx : array_like\n\t\ta knot vector\n\tn : int\n\t\tThe order of the spline. Must be non-negative, i.e., n >= 0\n\t\t\t'''\n\treturn DataContainer(\n\t\tx=dc[0].y,\n\t\ty=scipy.signal.bspline(\n\t\t\tx=dc[0].y,\n\t\t\tn=(int(params['n']) if params['n'] != '' else None),\n\t\t)\n\t)\n\n",
  "stft.py": "from flojoy import DataContainer, flojoy\nimport scipy.signal\n\n@flojoy\ndef STFT(dc, params):\n\t'''\n\t\tCompute the Short Time Fourier Transform (STFT).\n\t\t\n\t\tSTFTs can be used as a way of quantifying the change of a\n\t\tnonstationary signal's frequency and phase content over time.\n\t\t\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\tThe parameters of the function in this Flojoy wrapper are given below.\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\n\tParameters\n\t----------\n\tx : array_like\n\t\tTime series of measurement values\n\tfs : float, optional\n\t\tSampling frequency of the `x` time series. Defaults to 1.0.\n\twindow : str or tuple or array_like, optional\n\t\tDesired window to use. If `window` is a string or tuple, it is\n\t\tpassed to `get_window` to generate the window values, which are\n\t\tDFT-even by default. See `get_window` for a list of windows and\n\t\trequired parameters. If `window` is array_like it will be used\n\t\tdirectly as the window and its length must be nperseg. Defaults\n\t\tto a Hann window.\n\tnperseg : int, optional\n\t\tLength of each segment. Defaults to 256.\n\tnoverlap : int, optional\n\t\tNumber of points to overlap between segments. If `None`,\n\t\t``noverlap = nperseg // 2``. Defaults to `None`. When\n\t\tspecified, the COLA constraint must be met (see Notes below).\n\tnfft : int, optional\n\t\tLength of the FFT used, if a zero padded FFT is desired. If\n\t\t`None`, the FFT length is `nperseg`. Defaults to `None`.\n\tdetrend : str or function or `False`, optional\n\t\tSpecifies how to detrend each segment. If `detrend` is a\n\t\tstring, it is passed as the `type` argument to the `detrend`\n\t\tfunction. If it is a function, it takes a segment and returns a\n\t\tdetrended segment. If `detrend` is `False`, no detrending is\n\t\tdone. Defaults to `False`.\n\treturn_onesided : bool, optional\n\t\tIf `True`, return a one-sided spectrum for real data. If\n\t\t`False` return a two-sided spectrum. Defaults to `True`, but for\n\t\tcomplex data, a two-sided spectrum is always returned.\n\tboundary : str or None, optional\n\t\tSpecifies whether the input signal is extended at both ends, and\n\t\thow to generate the new values, in order to center the first\n\t\twindowed segment on the first input point. This has the benefit\n\t\tof enabling reconstruction of the first input point when the\n\t\temployed window function starts at zero. Valid options are\n\t\t``['even', 'odd', 'constant', 'zeros', None]``. Defaults to\n\t\t'zeros', for zero padding extension. I.e. ``[1, 2, 3, 4]`` is\n\t\textended to ``[0, 1, 2, 3, 4, 0]`` for ``nperseg=3``.\n\tpadded : bool, optional\n\t\tSpecifies whether the input signal is zero-padded at the end to\n\t\tmake the signal fit exactly into an integer number of window\n\t\tsegments, so that all of the signal is included in the output.\n\t\tDefaults to `True`. Padding occurs after boundary extension, if\n\t\t`boundary` is not `None`, and `padded` is `True`, as is the\n\t\tdefault.\n\taxis : int, optional\n\t\tAxis along which the STFT is computed; the default is over the\n\t\tlast axis (i.e. ``axis=-1``).\n\tscaling: {'spectrum', 'psd'}\n\t\tThe default 'spectrum' scaling allows each frequency line of `Zxx` to\n\t\tbe interpreted as a magnitude spectrum. The 'psd' option scales each\n\t\tline to a power spectral density - it allows to calculate the signal's\n\t\tenergy by numerically integrating over ``abs(Zxx)**2``.\n\t\t\n\t.. versionadded:: 1.9.0\n\t\t\t'''\n\treturn DataContainer(\n\t\tx=dc[0].y,\n\t\ty=scipy.signal.stft(\n\t\t\tx=dc[0].y,\n\t\t\tfs=(float(params['fs']) if params['fs'] != '' else None),\n\t\t\twindow=(str(params['window']) if params['window'] != '' else None),\n\t\t\tnperseg=(int(params['nperseg']) if params['nperseg'] != '' else None),\n\t\t\tnoverlap=(int(params['noverlap']) if params['noverlap'] != '' else None),\n\t\t\tnfft=(int(params['nfft']) if params['nfft'] != '' else None),\n\t\t\tdetrend=(bool(params['detrend']) if params['detrend'] != '' else None),\n\t\t\treturn_onesided=(bool(params['return_onesided']) if params['return_onesided'] != '' else None),\n\t\t\tboundary=(str(params['boundary']) if params['boundary'] != '' else None),\n\t\t\tpadded=(bool(params['padded']) if params['padded'] != '' else None),\n\t\t\taxis=(int(params['axis']) if params['axis'] != '' else None),\n\t\t\tscaling=(str(params['scaling']) if params['scaling'] != '' else None),\n\t\t)\n\t)\n\n",
  "argrelmax.py": "from flojoy import DataContainer, flojoy\nimport scipy.signal\n\n@flojoy\ndef ARGRELMAX(dc, params):\n\t'''\n\t\t\n\t\tCalculate the relative maxima of `data`.\n\t\t\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\tThe parameters of the function in this Flojoy wrapper are given below.\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\n\tParameters\n\t----------\n\tdata : ndarray\n\t\tArray in which to find the relative maxima.\n\taxis : int, optional\n\t\tAxis over which to select from `data`. Default is 0.\n\torder : int, optional\n\t\tHow many points on each side to use for the comparison\n\t\tto consider ``comparator(n, n+x)`` to be True.\n\tmode : str, optional\n\t\tHow the edges of the vector are treated.\n\t\tAvailable options are 'wrap' (wrap around) or 'clip' (treat overflow\n\t\tas the same as the last (or first) element).\n\t\tDefault 'clip'. See `numpy.take`.\n\t\t\t'''\n\treturn DataContainer(\n\t\tx=dc[0].y,\n\t\ty=scipy.signal.argrelmax(\n\t\t\tdata=dc[0].y,\n\t\t\taxis=(int(params['axis']) if params['axis'] != '' else None),\n\t\t\torder=(int(params['order']) if params['order'] != '' else None),\n\t\t\tmode=(str(params['mode']) if params['mode'] != '' else None),\n\t\t)\n\t)\n\n",
  "argrelmin.py": "from flojoy import DataContainer, flojoy\nimport scipy.signal\n\n@flojoy\ndef ARGRELMIN(dc, params):\n\t'''\n\t\t\n\t\tCalculate the relative minima of `data`.\n\t\t\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\tThe parameters of the function in this Flojoy wrapper are given below.\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\n\tParameters\n\t----------\n\tdata : ndarray\n\t\tArray in which to find the relative minima.\n\taxis : int, optional\n\t\tAxis over which to select from `data`. Default is 0.\n\torder : int, optional\n\t\tHow many points on each side to use for the comparison\n\t\tto consider ``comparator(n, n+x)`` to be True.\n\tmode : str, optional\n\t\tHow the edges of the vector are treated.\n\t\tAvailable options are 'wrap' (wrap around) or 'clip' (treat overflow\n\t\tas the same as the last (or first) element).\n\t\tDefault 'clip'. See numpy.take.\n\t\t\t'''\n\treturn DataContainer(\n\t\tx=dc[0].y,\n\t\ty=scipy.signal.argrelmin(\n\t\t\tdata=dc[0].y,\n\t\t\taxis=(int(params['axis']) if params['axis'] != '' else None),\n\t\t\torder=(int(params['order']) if params['order'] != '' else None),\n\t\t\tmode=(str(params['mode']) if params['mode'] != '' else None),\n\t\t)\n\t)\n\n",
  "hilbert.py": "from flojoy import DataContainer, flojoy\nimport scipy.signal\n\n@flojoy\ndef HILBERT(dc, params):\n\t'''\n\t\t\n\t\tCompute the analytic signal, using the Hilbert transform.\n\t\t\n\t\tThe transformation is done along the last axis by default.\n\t\t\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\tThe parameters of the function in this Flojoy wrapper are given below.\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\n\tParameters\n\t----------\n\tx : array_like\n\t\tSignal data.  Must be real.\n\tN : int, optional\n\tNumber of Fourier components.  Default: ``x.shape[axis]``\n\taxis : int, optional\n\tAxis along which to do the transformation.  Default: -1.\n\t\t\t'''\n\treturn DataContainer(\n\t\tx=dc[0].y,\n\t\ty=scipy.signal.hilbert(\n\t\t\tx=dc[0].y,\n\t\t\tN=(int(params['N']) if params['N'] != '' else None),\n\t\t\taxis=(int(params['axis']) if params['axis'] != '' else None),\n\t\t)\n\t)\n\n",
  "savgol_filter.py": "from flojoy import DataContainer, flojoy\nimport scipy.signal\n\n@flojoy\ndef SAVGOL_FILTER(dc, params):\n\t'''\n\t\tApply a Savitzky-Golay filter to an array.\n\t\t\n\t\tThis is a 1-D filter. If `x`  has dimension greater than 1, `axis`\n\t\tdetermines the axis along which the filter is applied.\n\t\t\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\tThe parameters of the function in this Flojoy wrapper are given below.\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\n\tParameters\n\t----------\n\tx : array_like\n\t\tThe data to be filtered. If `x` is not a single or double precision\n\t\tfloating point array, it will be converted to type ``numpy.float64``\n\t\tbefore filtering.\n\twindow_length : int\n\t\tThe length of the filter window (i.e., the number of coefficients).\n\t\tIf `mode` is 'interp', `window_length` must be less than or equal\n\t\tto the size of `x`.\n\tpolyorder : int\n\t\tThe order of the polynomial used to fit the samples.\n\t\t`polyorder` must be less than `window_length`.\n\tderiv : int, optional\n\t\tThe order of the derivative to compute. This must be a\n\t\tnonnegative integer. The default is 0, which means to filter\n\t\tthe data without differentiating.\n\tdelta : float, optional\n\t\tThe spacing of the samples to which the filter will be applied.\n\t\tThis is only used if deriv > 0. Default is 1.0.\n\taxis : int, optional\n\t\tThe axis of the array `x` along which the filter is to be applied.\n\t\tDefault is -1.\n\tmode : str, optional\n\t\tMust be 'mirror', 'constant', 'nearest', 'wrap' or 'interp'. This\n\t\tdetermines the type of extension to use for the padded signal to\n\t\twhich the filter is applied.  When `mode` is 'constant', the padding\n\t\tvalue is given by `cval`.  See the Notes for more details on 'mirror',\n\t\t'constant', 'wrap', and 'nearest'.\n\t\tWhen the 'interp' mode is selected (the default), no extension\n\t\tis used.  Instead, a degree `polyorder` polynomial is fit to the\n\t\tlast `window_length` values of the edges, and this polynomial is\n\t\tused to evaluate the last `window_length // 2` output values.\n\tcval : scalar, optional\n\t\tValue to fill past the edges of the input if `mode` is 'constant'.\n\t\tDefault is 0.0.\n\t\t\t'''\n\treturn DataContainer(\n\t\tx=dc[0].y,\n\t\ty=scipy.signal.savgol_filter(\n\t\t\tx=dc[0].y,\n\t\t\twindow_length=(int(params['window_length']) if params['window_length'] != '' else None),\n\t\t\tpolyorder=(int(params['polyorder']) if params['polyorder'] != '' else None),\n\t\t\tderiv=(int(params['deriv']) if params['deriv'] != '' else None),\n\t\t\tdelta=(float(params['delta']) if params['delta'] != '' else None),\n\t\t\taxis=(int(params['axis']) if params['axis'] != '' else None),\n\t\t\tmode=(str(params['mode']) if params['mode'] != '' else None),\n\t\t\tcval=(float(params['cval']) if params['cval'] != '' else None),\n\t\t)\n\t)\n\n",
  "decimate.py": "from flojoy import DataContainer, flojoy\nimport scipy.signal\n\n@flojoy\ndef DECIMATE(dc, params):\n\t'''\n\t\t\n\t\tDownsample the signal after applying an anti-aliasing filter.\n\t\t\n\t\tBy default, an order 8 Chebyshev type I filter is used. A 30 point FIR\n\t\tfilter with Hamming window is used if `ftype` is 'fir'.\n\t\t\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\tThe parameters of the function in this Flojoy wrapper are given below.\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\n\tParameters\n\t----------\n\tx : array_like\n\t\tThe signal to be downsampled, as an N-dimensional array.\n\tq : int\n\t\tThe downsampling factor. When using IIR downsampling, it is recommended\n\t\tto call `decimate` multiple times for downsampling factors higher than\n\t\t13.\n\tn : int, optional\n\t\tThe order of the filter (1 less than the length for 'fir'). Defaults to\n\t\t8 for 'iir' and 20 times the downsampling factor for 'fir'.\n\tftype : str {'iir', 'fir'} or ``dlti`` instance, optional\n\t\tIf 'iir' or 'fir', specifies the type of lowpass filter. If an instance\n\t\tof an `dlti` object, uses that object to filter before downsampling.\n\taxis : int, optional\n\t\tThe axis along which to decimate.\n\tzero_phase : bool, optional\n\t\tPrevent phase shift by filtering with `filtfilt` instead of `lfilter`\n\t\twhen using an IIR filter, and shifting the outputs back by the filter's\n\t\tgroup delay when using an FIR filter. The default value of ``True`` is\n\t\trecommended, since a phase shift is generally not desired.\n\t\t\n\t.. versionadded:: 0.18.0\n\t\t\t'''\n\treturn DataContainer(\n\t\tx=dc[0].y,\n\t\ty=scipy.signal.decimate(\n\t\t\tx=dc[0].y,\n\t\t\tq=(int(params['q']) if params['q'] != '' else None),\n\t\t\tn=(int(params['n']) if params['n'] != '' else None),\n\t\t\tftype=(str(params['ftype']) if params['ftype'] != '' else None),\n\t\t\taxis=(int(params['axis']) if params['axis'] != '' else None),\n\t\t\tzero_phase=(bool(params['zero_phase']) if params['zero_phase'] != '' else None),\n\t\t)\n\t)\n\n",
  "welch.py": "from flojoy import DataContainer, flojoy\nimport scipy.signal\n\n@flojoy\ndef WELCH(dc, params):\n\t'''\n\t\t\n\t\tEstimate power spectral density using Welch's method.\n\t\t\n\t\tWelch's method [1]_ computes an estimate of the power spectral\n\t\tdensity by dividing the data into overlapping segments, computing a\n\t\tmodified periodogram for each segment and averaging the\n\t\tperiodograms.\n\t\t\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\tThe parameters of the function in this Flojoy wrapper are given below.\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\n\tParameters\n\t----------\n\tx : array_like\n\t\tTime series of measurement values\n\tfs : float, optional\n\t\tSampling frequency of the `x` time series. Defaults to 1.0.\n\twindow : str or tuple or array_like, optional\n\t\tDesired window to use. If `window` is a string or tuple, it is\n\t\tpassed to `get_window` to generate the window values, which are\n\t\tDFT-even by default. See `get_window` for a list of windows and\n\t\trequired parameters. If `window` is array_like it will be used\n\t\tdirectly as the window and its length must be nperseg. Defaults\n\t\tto a Hann window.\n\tnperseg : int, optional\n\t\tLength of each segment. Defaults to None, but if window is str or\n\t\ttuple, is set to 256, and if window is array_like, is set to the\n\t\tlength of the window.\n\tnoverlap : int, optional\n\t\tNumber of points to overlap between segments. If `None`,\n\t\t``noverlap = nperseg // 2``. Defaults to `None`.\n\tnfft : int, optional\n\t\tLength of the FFT used, if a zero padded FFT is desired. If\n\t\t`None`, the FFT length is `nperseg`. Defaults to `None`.\n\tdetrend : str or function or `False`, optional\n\t\tSpecifies how to detrend each segment. If `detrend` is a\n\t\tstring, it is passed as the `type` argument to the `detrend`\n\t\tfunction. If it is a function, it takes a segment and returns a\n\t\tdetrended segment. If `detrend` is `False`, no detrending is\n\t\tdone. Defaults to 'constant'.\n\treturn_onesided : bool, optional\n\t\tIf `True`, return a one-sided spectrum for real data. If\n\t\t`False` return a two-sided spectrum. Defaults to `True`, but for\n\t\tcomplex data, a two-sided spectrum is always returned.\n\tscaling : { 'density', 'spectrum' }, optional\n\t\tSelects between computing the power spectral density ('density')\n\t\twhere `Pxx` has units of V**2/Hz and computing the power\n\t\tspectrum ('spectrum') where `Pxx` has units of V**2, if `x`\n\t\tis measured in V and `fs` is measured in Hz. Defaults to\n\t\t'density'\n\taxis : int, optional\n\t\tAxis along which the periodogram is computed; the default is\n\t\tover the last axis (i.e. ``axis=-1``).\n\taverage : { 'mean', 'median' }, optional\n\t\tMethod to use when averaging periodograms. Defaults to 'mean'.\n\t\t\n\t.. versionadded:: 1.2.0\n\t\t\t'''\n\treturn DataContainer(\n\t\tx=dc[0].y,\n\t\ty=scipy.signal.welch(\n\t\t\tx=dc[0].y,\n\t\t\tfs=(float(params['fs']) if params['fs'] != '' else None),\n\t\t\twindow=(str(params['window']) if params['window'] != '' else None),\n\t\t\tnperseg=(int(params['nperseg']) if params['nperseg'] != '' else None),\n\t\t\tnoverlap=(int(params['noverlap']) if params['noverlap'] != '' else None),\n\t\t\tnfft=(int(params['nfft']) if params['nfft'] != '' else None),\n\t\t\tdetrend=(str(params['detrend']) if params['detrend'] != '' else None),\n\t\t\treturn_onesided=(bool(params['return_onesided']) if params['return_onesided'] != '' else None),\n\t\t\tscaling=(str(params['scaling']) if params['scaling'] != '' else None),\n\t\t\taxis=(int(params['axis']) if params['axis'] != '' else None),\n\t\t\taverage=(str(params['average']) if params['average'] != '' else None),\n\t\t)\n\t)\n\n",
  "cubic.py": "from flojoy import DataContainer, flojoy\nimport scipy.signal\n\n@flojoy\ndef CUBIC(dc, params):\n\t'''\n\t\tA cubic B-spline.\n\t\t\n\t\tThis is a special case of `bspline`, and equivalent to ``bspline(x, 3)``.\n\t\t\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\tThe parameters of the function in this Flojoy wrapper are given below.\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\n\tParameters\n\t----------\n\tx : array_like\n\t\ta knot vector\n\t\t\t'''\n\treturn DataContainer(\n\t\tx=dc[0].y,\n\t\ty=scipy.signal.cubic(\n\t\t\tx=dc[0].y,\n\t\t\t)\n\t)\n\n",
  "quadratic.py": "from flojoy import DataContainer, flojoy\nimport scipy.signal\n\n@flojoy\ndef QUADRATIC(dc, params):\n\t'''\n\t\tA quadratic B-spline.\n\t\t\n\t\tThis is a special case of `bspline`, and equivalent to ``bspline(x, 2)``.\n\t\t\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\tThe parameters of the function in this Flojoy wrapper are given below.\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\n\tParameters\n\t----------\n\tx : array_like\n\t\ta knot vector\n\t\t\t'''\n\treturn DataContainer(\n\t\tx=dc[0].y,\n\t\ty=scipy.signal.quadratic(\n\t\t\tx=dc[0].y,\n\t\t\t)\n\t)\n\n",
  "czt.py": "from flojoy import DataContainer, flojoy\nimport scipy.signal\n\n@flojoy\ndef CZT(dc, params):\n\t'''\n\t\t\n\t\tCompute the frequency response around a spiral in the Z plane.\n\t\t\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\tThe parameters of the function in this Flojoy wrapper are given below.\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\n\tParameters\n\t----------\n\tx : array\n\t\tThe signal to transform.\n\tm : int, optional\n\t\tThe number of output points desired.  Default is the length of the\n\t\tinput data.\n\tw : complex, optional\n\t\tThe ratio between points in each step.  This must be precise or the\n\t\taccumulated error will degrade the tail of the output sequence.\n\t\tDefaults to equally spaced points around the entire unit circle.\n\ta : complex, optional\n\t\tThe starting point in the complex plane.  Default is 1+0j.\n\taxis : int, optional\n\t\tAxis over which to compute the FFT. If not given, the last axis is\n\t\tused.\n\t\t\t'''\n\treturn DataContainer(\n\t\tx=dc[0].y,\n\t\ty=scipy.signal.czt(\n\t\t\tx=dc[0].y,\n\t\t\tm=(int(params['m']) if params['m'] != '' else None),\n\t\t\tw=(complex(params['w']) if params['w'] != '' else None),\n\t\t\ta=(complex(params['a']) if params['a'] != '' else None),\n\t\t\taxis=(int(params['axis']) if params['axis'] != '' else None),\n\t\t)\n\t)\n\n",
  "detrend.py": "from flojoy import DataContainer, flojoy\nimport scipy.signal\n\n@flojoy\ndef DETREND(dc, params):\n\t'''\n\t\t\n\t\tRemove linear trend along axis from data.\n\t\t\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\tThe parameters of the function in this Flojoy wrapper are given below.\n\t-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\n\tParameters\n\t----------\n\tdata : array_like\n\t\tThe input data.\n\taxis : int, optional\n\t\tThe axis along which to detrend the data. By default this is the\n\t\tlast axis (-1).\n\ttype : {'linear', 'constant'}, optional\n\t\tThe type of detrending. If ``type == 'linear'`` (default),\n\t\tthe result of a linear least-squares fit to `data` is subtracted\n\t\tfrom `data`.\n\t\tIf ``type == 'constant'``, only the mean of `data` is subtracted.\n\tbp : array_like of ints, optional\n\t\tA sequence of break points. If given, an individual linear fit is\n\t\tperformed for each part of `data` between two break points.\n\t\tBreak points are specified as indices into `data`. This parameter\n\t\tonly has an effect when ``type == 'linear'``.\n\toverwrite_data : bool, optional\n\t\tIf True, perform in place detrending and avoid a copy. Default is False\n\t\t\t'''\n\treturn DataContainer(\n\t\tx=dc[0].y,\n\t\ty=scipy.signal.detrend(\n\t\t\tdata=dc[0].y,\n\t\t\taxis=(int(params['axis']) if params['axis'] != '' else None),\n\t\t\ttype=(str(params['type']) if params['type'] != '' else None),\n\t\t\tbp=(int(params['bp']) if params['bp'] != '' else None),\n\t\t\toverwrite_data=(bool(params['overwrite_data']) if params['overwrite_data'] != '' else None),\n\t\t)\n\t)\n\n",
  "SKLEARNIMAGE.py": "from flojoy import flojoy, DataContainer\nfrom skimage import data\n\n\n@flojoy\ndef SKLEARNIMAGE(dc_inputs, params):\n    \"\"\"Node designed to load example images from scikit-image.\n\n    Examples can be found here:\n    https://scikit-image.org/docs/stable/auto_examples/index.html\n\n    \"\"\"\n    img_key = params[\"img_key\"]\n\n    img_array = getattr(data, img_key)()\n\n    if len(img_array.shape) == 2:\n        red = green = blue = img_array\n        alpha = None\n    elif len(img_array.shape) == 3:\n        # Color image\n        if img_array.shape[2] == 3:\n            red, green, blue = (\n                img_array[:, :, 0],\n                img_array[:, :, 1],\n                img_array[:, :, 2],\n            )\n            alpha = None\n        elif img_array.shape[2] == 4:\n            red, green, blue, alpha = (\n                img_array[:, :, 0],\n                img_array[:, :, 1],\n                img_array[:, :, 2],\n                img_array[:, :, 3],\n            )\n\n    return DataContainer(\n        type=\"image\",\n        r=red,\n        g=green,\n        b=blue,\n        a=alpha,\n    )\n",
  "SECOND_ORDER_SYSTEM.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\nfrom node_sdk.small_memory import SmallMemory\n\nmemory_key = \"SECOND_ORDER_SYSTEM\"\n\n\n@flojoy\ndef SECOND_ORDER_SYSTEM(v, params):\n    # Let's first define things that won't change over\n    # each iteration: time constants, etc ...\n    d1 = float(params[\"d1\"])  # first time constant in us, 250\n    d2 = float(params[\"d2\"])  # second time constant in us, 100\n    node_id = params.get(\"node_id\", 0)\n\n    # ... and now some helper functions\n    x1 = np.exp(-1.0 / d1) if d1 > 0 else 0.0\n    x2 = np.exp(-1.0 / d2) if d2 > 0 else 0.0\n    ac = (1.0 - x1) * (1.0 - x2)\n    bpd = x1 + x2\n    bd = x1 * x2\n\n    # Now we require memory. The only thing we need in memory is the last two\n    # values the system had in this basic example.\n    data = SmallMemory().read_memory(node_id, memory_key)\n    if type(data) == dict:\n        initialize = True\n    elif type(data) == np.ndarray:\n        initialize = False\n    else:\n        raise TypeError(\"Error loading object from REDIS.\")\n\n    # We're going to store and read the data in reverse order to\n    # how it is accessed here. We will write the functionality\n    # below to assume the most recent time step is the first\n    # index. However, for visualization and external access,\n    # it makes the most sense to have the first time step\n    # as the first index!\n    y_primes = np.zeros((2, 1)) if initialize else data[::-1]\n\n    # Using input from controller as v[0].y ...\n    response = ac * v[0].y[-1] + bpd * y_primes[0] - bd * y_primes[1]\n    y_primes[1] = y_primes[0]\n\n    # prepend the most recent result to the front of the histrory\n    y_primes = np.insert(y_primes, 0, response)\n    # We now write to memory, reversing the order ...\n    SmallMemory().write_to_memory(node_id, memory_key, y_primes[::-1])\n    # ... and return the result!\n    return DataContainer(\n        x=v[0].y, y=np.ones_like(v[0].y) * float(y_primes[0])\n    )  # returns input output pair\n",
  "SINE.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\nfrom scipy import signal\n\n\n@flojoy\ndef SINE(v, params):\n    valid_waveforms = [\"sine\", \"square\", \"triangle\", \"sawtooth\"]\n    x = None\n    if v.__len__() > 0:\n        x = v[0].y\n\n    waveform = params[\"waveform\"]\n    A = float(params[\"amplitude\"])\n    F = float(params[\"frequency\"])\n    Y0 = float(params[\"offset\"])\n    PHASE = float(params[\"phase\"])\n    if waveform not in valid_waveforms:\n        waveform = valid_waveforms[0]\n        print(\"invalid waveform passed as param, using default:\", waveform)\n\n    if waveform == \"sine\":\n        y = Y0 + A * np.sin(np.radians(2 * np.pi * F) * x + np.radians(PHASE))\n    elif waveform == \"square\":\n        y = Y0 + A * signal.square(2 * np.pi * F * x / 10 + np.radians(PHASE))\n    elif waveform == \"triangle\":\n        y = Y0 + A * signal.sawtooth(2 * np.pi * F * x / 10 + np.radians(PHASE), 0.5)\n    elif waveform == \"sawtooth\":\n        y = Y0 + A * signal.sawtooth(2 * np.pi * F / 10 * x + np.radians(PHASE))\n\n    return DataContainer(x=x, y=y)\n",
  "LINSPACE.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef LINSPACE(v, params):\n    x = None\n    if v.__len__() > 0:\n        x = v[0].y\n    y = np.linspace(float(params[\"start\"]), float(params[\"end\"]), int(params[\"step\"]))\n    result = DataContainer(x=x, y=y)\n    return result\n",
  "RAND.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\nimport traceback\n\n\n@flojoy\ndef RAND(v, params):\n    x = None\n    if len(v) > 0:\n        x = v[0].y\n        y = np.random.normal(size=len(x))\n    else:\n        y = np.random.normal(size=1000)\n\n    return DataContainer(x=x, y=y)\n\n\n@flojoy\ndef RAND_MOCK(v, params):\n    print(\"running mock version of rand\")\n    x = None\n    if len(v) > 0:\n        x = v[0].y\n        y = x\n    else:\n        y = np.full(\n            1000, 1000\n        )  # for reproducibility returning an array with constant values\n    return DataContainer(x=x, y=y)\n",
  "FEEDBACK.py": "from flojoy import flojoy, DataContainer, get_job_result\nfrom rq.job import NoSuchJobError\nimport traceback\n\n\n@flojoy\ndef FEEDBACK(v, params):\n    referred_node = params[\"referred_node\"]\n\n    try:\n        result = get_job_result(referred_node)\n        return result\n    except (Exception, NoSuchJobError) as e:\n        x = v[0].x\n        y = v[0].y\n        print(\"Job not found: \", e, traceback.format_exc())\n        return DataContainer(x=x, y=y)\n",
  "CONSTANT.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\n\n\n@flojoy\ndef CONSTANT(v, params):\n    \"\"\"Generates a single x-y vector of numeric (floating point) constants\"\"\"\n\n    if v.__len__() > 0:\n        x = v[0].y\n        y = np.full(len(x), float(params[\"constant\"]))\n        return DataContainer(x=x, y=y)\n\n    x = list()\n    for i in range(1000):\n        x.append(i)\n    y = np.full(1000, float(params[\"constant\"]))\n\n    return DataContainer(x=x, y=y)\n",
  "TIMESERIES.py": "import numpy as np\nfrom flojoy import flojoy, DataContainer\nimport pandas.testing as testing\nimport traceback\n\n\n@flojoy\ndef TIMESERIES(v, params):\n    \"\"\"\n    Generates a random timeseries vector\n    \"\"\"\n\n    try:\n        np.random.seed(1)\n        testing.N, testing.K = 1000, 1  # rows, columns\n        df = testing.makeTimeDataFrame(freq=\"MS\")\n    except Exception:\n        print(traceback.format_exc())\n\n    return DataContainer(x=df.index.to_numpy(), y=df[\"A\"].to_numpy())\n",
  "R_DATASET.py": "from flojoy import flojoy, DataContainer\nfrom rdatasets import data\n\n\n@flojoy\ndef R_DATASET(dc_inputs: list[DataContainer], params: dict) -> DataContainer:\n    \"\"\"\n    Retrieves a pandas DataFrame from rdatasets using the provided dataset_key parameter and returns it wrapped in a DataContainer.\n\n    Args:\n        dc_inputs (list[DataContainer]): A list of DataContainer objects, but not used in this function.\n        params (dict): A dictionary of parameters for this function.\n            dataset_key (str): The key used to retrieve the DataFrame.\n\n    Returns:\n        DataContainer: A DataContainer object containing the retrieved pandas DataFrame.\n    \"\"\"\n    dataset_key = params[\"dataset_key\"]\n    df = data(dataset_key)\n    return DataContainer(type=\"dataframe\", m=df)\n",
  "template.py": "import plotly.graph_objects as go\n\n\ndef init_template():\n    template = go.layout.Template()\n\n    # pythonic autotyping of numeric strings\n    template.layout.autotypenumbers = \"strict\"\n\n    # minimiz margins\n    # template.layout.margin = dict(t=0, l=10, b=10, r=0)\n\n    return template\n",
  "BAR.py": "from flojoy import flojoy, DataContainer\nimport plotly.graph_objects as go\nimport pandas as pd\n\n\n@flojoy\ndef BAR(dc_inputs: list[DataContainer], params: dict) -> DataContainer:\n    \"\"\"Node creates a Plotly Bar visualization for a given input data container.\"\"\"\n    dc_input = dc_inputs[0]\n    fig = go.Figure()\n    match dc_input.type:\n        case \"ordered_pair\":\n            x = dc_input.x\n            if isinstance(dc_input.x, dict):\n                dict_keys = list(dc_input.x.keys())\n                x = dc_input.x[dict_keys[0]]\n            y = dc_input.y\n            fig.add_trace(go.Bar(x=x, y=y))\n        case \"dataframe\":\n            df = pd.DataFrame(dc_input.m)\n            for col in df.columns:\n                if df[col].dtype == \"object\":\n                    counts = df[col].value_counts()\n                    fig.add_trace(\n                        go.Bar(x=counts.index.tolist(), y=counts.tolist(), name=col)\n                    )\n                else:\n                    fig.add_trace(go.Bar(x=df.index, y=df[col], name=col))\n            fig.update_layout(\n                title=\"Bar Plot\", xaxis_title=\"X Axis\", yaxis_title=\"Y Axis\"\n            )\n        case _:\n            raise ValueError(\"unsupported DataContainer type for BAR node\")\n\n    return DataContainer(type=\"plotly\", fig=fig)\n",
  "TABLE.py": "from flojoy import flojoy, DataContainer\nimport plotly.graph_objects as go\nimport pandas as pd\n\n\n@flojoy\ndef TABLE(dc_inputs: list[DataContainer], params: dict):\n    \"\"\"Node creates a Plotly table visualization for a given input data container.\n\n    Args:\n    dc_inputs (list): A list of DataContainer object(s) containing the input data.\n    params (dict): A dictionary containing the parameters needed for the visualization.\n\n    Returns:\n    DataContainer: A DataContainer object containing the generated visualization and the processed data.\n\n    Raises:\n    ValueError: If the input data container is not supported.\n    \"\"\"\n    dc_input = dc_inputs[0]\n    if dc_input.type in [\"dataframe\", \"plotly\"]:\n        df = pd.DataFrame(dc_input.m)\n        fig = go.Figure(\n            data=[\n                go.Table(\n                    header=dict(values=list(df.columns), align=\"left\"),\n                    cells=dict(values=[df[col] for col in df.columns], align=\"left\"),\n                )\n            ]\n        )\n        return DataContainer(type=\"plotly\", fig=fig, m=df)\n    else:\n        raise ValueError(\"unsupported DataContainer type for Plotly TABLE node\")\n",
  "LINE.py": "from flojoy import flojoy, DataContainer\nimport plotly.graph_objects as go\nimport pandas as pd\n\n\n@flojoy\ndef LINE(dc_inputs: list[DataContainer], params: dict) -> DataContainer:\n    \"\"\"Node creates a Plotly Line visualization for a given input data container.\"\"\"\n    dc_input = dc_inputs[0]\n    fig = go.Figure()\n    match dc_input.type:\n        case \"ordered_pair\":\n            x = dc_input.x\n            if isinstance(dc_input.x, dict):\n                dict_keys = list(dc_input.x.keys())\n                x = dc_input.x[dict_keys[0]]\n            y = dc_input.y\n            fig.add_trace(go.Line(x=x, y=y, mode=\"lines\"))\n        case \"dataframe\":\n            df = pd.DataFrame(dc_input.m)\n            for col in df.columns:\n                fig.add_trace(go.Scatter(x=df.index, y=df[col], mode=\"lines\", name=col))\n                fig.update_layout(\n                    title=\"Line Plot\", xaxis_title=\"X Axis\", yaxis_title=\"Y Axis\"\n                )\n        case _:\n            raise ValueError(\"unsupported DataContainer type for LINE node\")\n    return DataContainer(type=\"plotly\", fig=fig)\n",
  "HISTOGRAM.py": "from flojoy import flojoy, DataContainer\nimport plotly.graph_objects as go\nimport pandas as pd\n\n\n@flojoy\ndef HISTOGRAM(dc_inputs: list[DataContainer], params: dict):\n    \"\"\"Node creates a Plotly Histogram visualization for a given input data container.\"\"\"\n    dc_input = dc_inputs[0]\n    fig = go.Figure()\n    match dc_input.type:\n        case \"ordered_pair\":\n            x = dc_input.x\n            if isinstance(dc_input.x, dict):\n                dict_keys = list(dc_input.x.keys())\n                x = dc_input.x[dict_keys[0]]\n            y = dc_input.y\n            fig.add_trace(go.Histogram(x=x, y=y))\n        case \"dataframe\":\n            df = pd.DataFrame(dc_input.m)\n            for col in df.columns:\n                fig.add_trace(go.Histogram(x=df[col], name=col))\n            fig.update_layout(\n                title=\"Histogram Plot\", xaxis_title=\"Value\", yaxis_title=\"Frequency\"\n            )\n        case _:\n            raise ValueError(\"unsupported DataContainer type for HISTOGRAM node\")\n\n    return DataContainer(type=\"plotly\", fig=fig)\n",
  "SCATTER3D.py": "import plotly.graph_objects as go\nfrom flojoy import DataContainer, flojoy\n\n\n@flojoy\ndef SCATTER3D(v, params):\n    dc_input = v[0]\n    if dc_input.type == \"ordered_triple\":\n        x = dc_input.x\n        if isinstance(dc_input.x, dict):\n            dict_keys = list(dc_input.x.keys())\n            x = dc_input.x[dict_keys[0]]\n        y = dc_input.y\n        z = dc_input.z\n    else:\n        raise ValueError(\"unsupported input type for SCATTER3D node\")\n    fig = go.Figure(data=go.Scatter3d(x=x, y=y, z=z, mode=\"markers\"))\n    return DataContainer(type=\"plotly\", fig=fig, x=x, y=y, z=z)\n",
  "SCATTER.py": "import plotly.graph_objects as go\nfrom flojoy import flojoy, DataContainer\nimport pandas as pd\n\n\n@flojoy\ndef SCATTER(dc_inputs: list[DataContainer], params: dict) -> DataContainer:\n    \"\"\"Node creates a Plotly Scatter visualization for a given input data container.\"\"\"\n    dc_input = dc_inputs[0]\n    fig = go.Figure()\n    match dc_input.type:\n        case \"ordered_pair\":\n            x = dc_input.x\n            if isinstance(dc_input.x, dict):\n                dict_keys = list(dc_input.x.keys())\n                x = dc_input.x[dict_keys[0]]\n            y = dc_input.y\n            fig.add_trace(go.Scatter(x=x, y=y, mode=\"markers\"))\n        case \"dataframe\":\n            df = pd.DataFrame(dc_input.m)\n            for col in df.columns:\n                fig.add_trace(\n                    go.Scatter(x=df[col], y=df.index, mode=\"markers\", name=col)\n                )\n            fig.update_layout(\n                title=\"Scatter Plot\", xaxis_title=\"X Axis\", yaxis_title=\"Y Axis\"\n            )\n        case _:\n            raise ValueError(\"unsupported DataContainer type for SCATTER node\")\n    return DataContainer(type=\"plotly\", fig=fig)\n",
  "SURFACE3D.py": "import plotly.graph_objects as go\nfrom flojoy import DataContainer, flojoy\n\n\n@flojoy\ndef SURFACE3D(v, params):\n    dc_input = v[0]\n    if dc_input.type == \"ordered_triple\":\n        x = dc_input.x\n        if isinstance(dc_input.x, dict):\n            dict_keys = list(dc_input.x.keys())\n            x = dc_input.x[dict_keys[0]]\n        y = dc_input.y\n        z = dc_input.z\n    else:\n        raise ValueError(\"unsupported input type for SURFACE3D node\")\n    fig = go.Figure(data=go.Surface(x=x, y=y, z=z, mode=\"markers\"))\n    return DataContainer(type=\"plotly\", fig=fig, x=x, y=y, z=z)\n",
  "IMAGE.py": "from flojoy import flojoy, DataContainer\nimport plotly.express as px\nimport numpy as np\n\n\n@flojoy\ndef IMAGE(v, params):\n    dc_input = v[0]\n    if dc_input.type == \"image\":\n        r = dc_input.r\n        g = dc_input.g\n        b = dc_input.b\n        a = dc_input.a\n    else:\n        raise ValueError(\"unsupported input type for IMAGE node\")\n    if a is None:\n        img_combined = np.stack((r, g, b), axis=2)\n    else:\n        img_combined = np.stack((r, g, b, a), axis=2)\n    fig = px.imshow(img=img_combined)\n\n    return DataContainer(type=\"plotly\", fig=fig, r=r, g=g, b=b, a=a)\n",
  "LOCAL_FILE.py": "import traceback\nfrom flojoy import flojoy, DataContainer, JobResultBuilder\nimport numpy as np\nfrom PIL import Image\nfrom os import path\n\n\n@flojoy\ndef LOCAL_FILE(v, params):\n    print(\"parameters passed to LOCAL_FILE: \", params)\n    file_type = params[\"file_type\"]\n    match file_type:\n        case \"image\":\n            red_channel = []\n            green_channel = []\n            blue_channel = []\n            alpha_channel = []\n            try:\n                default_image_path = path.join(\n                    path.dirname(path.abspath(__file__)),\n                    \"assets\",\n                    \"astronaut.png\",\n                )\n                filePath = params[\"path\"]\n                if filePath == \"\":\n                    filePath = default_image_path\n                print(\" file will be loaded from: \", filePath)\n                f = Image.open(filePath)\n                img_array = np.array(f.convert(\"RGBA\"))\n                if img_array.shape[2] == 4:\n                    red_channel = img_array[:, :, 0]\n                    green_channel = img_array[:, :, 1]\n                    blue_channel = img_array[:, :, 2]\n                    alpha_channel = img_array[:, :, 3]\n                else:\n                    red_channel = img_array[:, :, 0]\n                    green_channel = img_array[:, :, 1]\n                    blue_channel = img_array[:, :, 2]\n                    alpha_channel = None\n            except Exception:\n                print(traceback.format_exc())\n            return DataContainer(\n                type=\"image\",\n                r=red_channel,\n                g=green_channel,\n                b=blue_channel,\n                a=alpha_channel,\n            )\n        case _:\n            return JobResultBuilder().from_inputs(v).build()\n",
  "LOADER.py": "import json\nimport os\nfrom datetime import datetime\nfrom pathlib import Path\n\nimport requests\nimport yaml\nfrom flojoy import DataContainer, flojoy\nfrom flojoy.utils import PlotlyJSONEncoder\n\nFRONTIER_URI = (\n    os.environ.get(\"FRONTIER_URI\")\n    or \"https://cipfsgeml2.execute-api.us-east-1.amazonaws.com\"\n)\nMEASUREMENT_API = f\"{FRONTIER_URI}/measurements\"\n\n\n@flojoy\ndef LOADER(dc_inputs: list[DataContainer], params: dict):\n    api_key = get_api_key()\n    measurement_uuid = params[\"measurement_uuid\"]\n\n    if api_key != \"\" and measurement_uuid != \"\":\n        try:\n            requests.post(\n                f\"{MEASUREMENT_API}/{measurement_uuid}\",\n                json={\n                    \"api_key\": api_key,\n                    \"measurements\": json.dumps(\n                        {\"data\": dc_inputs[0]}, cls=PlotlyJSONEncoder\n                    ),\n                    \"time\": datetime.now().__str__(),\n                },\n            )\n        except Exception as e:\n            raise e\n        return dc_inputs[0]\n    else:\n        not_found_key = \"FRONTIER_API_KEY\" if api_key == \"\" else \"Measurement UUID\"\n        raise KeyError(f\"{not_found_key} not found!\")\n\n\ndef get_api_key():\n    home = str(Path.home())\n    api_key = \"\"\n    path = os.path.join(home, \".flojoy/credentials\")\n    if not os.path.exists(path):\n        return api_key\n\n    stream = open(path, \"r\", encoding=\"utf-8\")\n    yaml_dict = yaml.load(stream, Loader=yaml.FullLoader)\n    if yaml_dict is None:\n        return api_key\n    if isinstance(yaml_dict, str) == True:\n        split_by_line = yaml_dict.split(\"\\n\")\n        for line in split_by_line:\n            if \"FRONTIER_API_KEY\" in line:\n                api_key = line.split(\":\")[1]\n    else:\n        api_key = yaml_dict.get(\"FRONTIER_API_KEY\", \"\")\n    return api_key\n"
}
