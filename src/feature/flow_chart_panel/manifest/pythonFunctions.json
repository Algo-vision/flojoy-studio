{"GENERATOR": {"SINE.py": "import numpy as np\nfrom joyflo import flojoy, DataContainer\nfrom scipy import signal\n\n@flojoy\ndef SINE(v, params):\n    valid_waveforms = [\"sine\", \"square\", \"triangle\", \"sawtooth\"]\n    print(' sine params: ', params)\n    x = None\n    if v.__len__() > 0:\n        x = v[0].y\n\n    waveform = params['waveform']\n    A = int(params['amplitude'])\n    F = int(params['frequency'])\n    Y0 =int( params['offset'])\n    if waveform not in valid_waveforms:\n        waveform = valid_waveforms[0]\n        print('invalid waveform passed as param, using default:', waveform)\n\n    if waveform == 'sine':\n        y = Y0 + A * np.sin(np.radians(2 * np.pi * F) * x)\n    elif waveform == 'square':\n        y = Y0 + A * signal.square(2 * np.pi * F * x / 10)\n    elif waveform == 'triangle':\n        y = Y0 + A * signal.sawtooth(2 * np.pi * F * x / 10, 0.5)\n    elif waveform == 'sawtooth':\n        y = Y0 + A * signal.sawtooth(2 * np.pi * F / 10 * x)\n\n    return DataContainer(x = x, y = y)\n", "LINSPACE.py": "import numpy as np\nfrom joyflo import flojoy, DataContainer\n\n@flojoy\ndef LINSPACE(v, params):\n    x = None\n    if v.__len__() > 0:\n        x = v[0].y\n    y = np.linspace(int(params['start']), int(params['end']), int(params['step']))\n    result = DataContainer(x = x, y = y)\n    return result", "CONSTANT.py": "import numpy as np\nfrom joyflo import flojoy, DataContainer\n\n@flojoy\ndef CONSTANT(v, params):\n    # ''' Generates a single x-y vector of numeric (floating point) constants'''\n    print('constant params: ',params)\n\n    if v.__len__() > 0:\n        x = v[0].y\n        y = np.full(len(x), float(params['constant']))\n        return DataContainer(x = x, y = y)\n\n    x = list()\n    for i in range(1000):\n        x.append(i)\n    y = np.full(1000, float(params['constant']))\n\n    return DataContainer(x = x, y = y)\n", "RAND.py": "import numpy as np\nfrom joyflo import flojoy, DataContainer\nimport traceback\n\n@flojoy\ndef RAND(v, params):\n    try:\n        x = v[0].y\n        y = x\n        # y = np.random.normal(size=len(x))\n    except Exception:\n        print(traceback.format_exc())\n\n    return DataContainer(x = x, y = y)\n"}, "TRANSFORMER": {"ADD.py": "import numpy as np\nfrom joyflo import flojoy, DataContainer\n\n@flojoy\ndef ADD(v, params):\n    ''' Add 2 input vectors and return the result '''\n    a = [0]\n    b = [0]\n\n    if len(v) == 2:\n        a = v[0].y\n        b = v[1]['y']\n\n    y = np.add(a, b)\n\n    return DataContainer(x = [a, b], y = y)", "MULTIPLY.py": "import numpy as np\nfrom joyflo import flojoy, DataContainer\n\n@flojoy\ndef MULTIPLY(v, params):\n    ''' Takes 2 input vectors, multiplies them, and returns the result '''\n\n    a = v[0].y\n    b = v[1].y\n\n    y = np.multiply(a, b)\n\n    return DataContainer(x = [a, b], y = y)"}, "VISOR": {"SCATTER.py": "from joyflo import flojoy\nfrom .template import init_template\n\n@flojoy\ndef SCATTER(v, params):\n\n    fig = dict(\n        data = [dict(\n            x = list(v[0].x),\n            y = list(v[0].y),\n            type='scatter',\n            mode='markers'\n        )],\n        layout = dict(template = init_template())\n    )\n    return fig", "template.py": "import plotly.graph_objects as go\n\ndef init_template():\n\n    template = go.layout.Template()\n\n    # pythonic autotyping of numeric strings\n    template.layout.autotypenumbers = \"strict\"\n\n    # minimiz margins\n    # template.layout.margin = dict(t=0, l=10, b=10, r=0)\n\n    return template\n\n", "SCATTER3D.py": "from joyflo import flojoy\nfrom .template import init_template\n\n@flojoy\ndef SCATTER3D(v, params):\n\n    fig = dict(\n        data = [dict(\n            x = list(v[0].x),\n            y = list(v[0].y),\n            z =  list([0] * len(v[0].x)),\n            type='scatter3d',\n            mode='markers'\n        )],\n        layout = dict(template = init_template())\n    )\n    # list(v[0].z) if v[0].z is not None else\n    return fig", "HISTOGRAM.py": "from joyflo import flojoy\nfrom .template import init_template\n\n@flojoy\ndef HISTOGRAM(v, params):\n\n    fig = dict(\n        data = [dict(x = list(v[0].x), type='histogram',)],\n        layout = dict(template = init_template())\n    )\n    return fig", "LINE.py": "from joyflo import flojoy\nfrom .template import init_template\n\n@flojoy\ndef LINE(v, params):\n\n    fig = dict(\n        data = [dict(\n            x = list(v[0].x),\n            y = list(v[0].y),\n            type='scatter',\n            mode='lines'\n        )],\n        layout = dict(template = init_template())\n    )\n    return fig", "SURFACE3D.py": "from joyflo import flojoy\nfrom .template import init_template\n\n@flojoy\ndef SURFACE3D(v, params):\n\n    fig = dict(\n        data = [dict(\n            x = list(v[0].x),\n            y = list(v[0].y),\n            z =  list([0] * len(v[0].y)),\n            type='surface'\n        )],\n        layout = dict(template = init_template())\n    )\n    # list(v[0].z) if v[0].z is not None else\n    return fig", "BAR.py": "from joyflo import flojoy\nfrom .template import init_template\n\n@flojoy\ndef BAR(v, params):\n    fig = dict(\n        data = [dict(x = list(v[0].x), y = list(v[0].y), type='bar')],\n        layout = dict(template = init_template())\n    )\n    return fig"}, "COMPARATOR": {"CONDITIONAL.py": "from joyflo import flojoy,VectorXY\nfrom redis import Redis\nimport os\nimport json\n\nREDIS_HOST = os.environ.get('REDIS_HOST', 'localhost')\nREDIS_PORT = os.environ.get('REDIS_PORT', 6379)\nr = Redis(host=REDIS_HOST, port=REDIS_PORT)\n\ndef get_iteration_info(jobset_id):\n\n    env_info = r.get(jobset_id)\n    parse_obj = json.loads(env_info) if env_info is not None else {}\n\n    special_type_jobs = parse_obj['SPECIAL_TYPE_JOBS'] if 'SPECIAL_TYPE_JOBS' in parse_obj else {}\n\n    if len(special_type_jobs):\n        return special_type_jobs['LOOP']['params']['initial_value'],special_type_jobs['LOOP']['params']['total_iterations'],special_type_jobs['LOOP']['params']['step']\n    return None,None,None\n\ndef set_body_execution_done(jobset_id):\n\n    env_info = r.get(jobset_id)\n    r_obj = json.loads(env_info) if env_info is not None else {}\n    special_type_jobs = r_obj['SPECIAL_TYPE_JOBS'] if 'SPECIAL_TYPE_JOBS' in r_obj else {}\n\n    loop_jobs = {\n        \"status\":\"finished\",\n        \"is_loop_body_execution_finished\":True,\n        \"params\":{}\n    }\n\n    conditional_jobs = {\n        \"direction\":True\n    }\n\n    r.set(jobset_id, json.dumps({\n        **r_obj,\n        'SPECIAL_TYPE_JOBS':{\n            **special_type_jobs,\n            'LOOP':loop_jobs,\n            'CONDITIONAL':conditional_jobs\n        }\n    }))\n\ndef increase_current_iteration(jobset_id,initial_value,total_iterations,step):\n\n    env_info = r.get(jobset_id)\n    r_obj = json.loads(env_info) if env_info is not None else {}\n    special_type_jobs = r_obj['SPECIAL_TYPE_JOBS'] if 'SPECIAL_TYPE_JOBS' in r_obj else {}\n\n    loop_jobs = {\n        \"status\":\"ongoing\",\n        \"is_loop_body_execution_finished\":False,\n        \"params\":{\n                \"initial_value\":initial_value + step,\n                \"total_iterations\":total_iterations,\n                \"step\":step\n            }\n    }\n\n    conditional_jobs = {\n        \"direction\":False\n    }\n\n    r.set(jobset_id, json.dumps({\n        **r_obj,\n        'SPECIAL_TYPE_JOBS':{\n            **special_type_jobs,\n            'LOOP':loop_jobs,\n            'CONDITIONAL':conditional_jobs\n        }\n    }))\n\n@flojoy\ndef CONDITIONAL(v,params):\n    print(\"EXECUTING CONDITIONAL PARAMS\")\n    print(params)\n    jobset_id = params['jobset_id']\n    operator = params['operator_type']\n\n    initial_value, total_iterations,step = get_iteration_info(jobset_id)\n\n    print(\"initial value \",initial_value)\n\n    if operator == \"<=\":\n        bool_ = total_iterations <= initial_value + step\n    elif operator == \">\":\n        bool_ = total_iterations > initial_value + step\n    elif operator == \"<\":\n        bool_ = total_iterations < initial_value + step\n    elif operator == \">=\":\n        bool_ = total_iterations < initial_value + step\n    elif operator == \"!=\" :\n        bool_ = total_iterations != initial_value + step\n    else:\n        bool_ = total_iterations == initial_value + step\n    print(\"Bool value: \",bool_)\n\n    if bool_:\n        set_body_execution_done(jobset_id)\n    else:\n        increase_current_iteration(jobset_id,initial_value,total_iterations,step)\n\n    return VectorXY(x=v[0].x,y=v[0].y)"}, "LOOP": {"LOOP.py": "'''\nimport numpy as np\nfrom .VCTR import fetch_inputs\n\nfrom redis import Redis\nfrom rq.job import Job\nimport os\n\nREDIS_HOST = os.environ.get('REDIS_HOST', 'localhost')\nREDIS_PORT = os.environ.get('REDIS_PORT', 6379)\n\n\ndef LOOP(**kwargs):\n\n    if \"previous_job_ids\" in kwargs:\n\n\n        #   Checking if there's a conditional node with previous iteration output\n\n\n        previous_job_ids = kwargs['previous_job_ids']\n\n        conditional_job_result = None\n        for prev_id in previous_job_ids:\n            job = Job.fetch(prev_id, connection=Redis(host=REDIS_HOST, port=REDIS_PORT))\n            if \"CONDITIONAL_OPERATOR\" in job.kwargs['ctrls']:\n                conditional_job_result = job.result\n                break\n\n        if conditional_job_result is not None:\n            print(conditional_job_result)\n            return {'x0':conditional_job_result['x0'],'y0':conditional_job_result['y0']}\n\n        previous_job_ids = kwargs['previous_job_ids']\n        previous_job_results = fetch_inputs(previous_job_ids)\n\n\n    return {'x0':[1,2,3],'y0':[2,3,4]} # returning random value\n'''\nfrom joyflo import flojoy,VectorXY\n\n@flojoy\ndef LOOP(v,params):\n    print(\"EXECUTING LOOP\")\n\n    # if len(v) == 2:\n    #     print(v[0])\n    #     y = v[0][0].y\n    #     x = v[0][0].x\n    # else:\n    #     y = v[0].y\n    #     x = v[0].x\n\n    # print(\"y\",y)\n    # print(\"x\",x)\n\n    # print(x)\n\n    # if x == None:\n    #     x = y\n    return VectorXY(x=[1,2,3,4,5],y=[1,2,3,4,5,6])"}, "TIMER": {"TIMER.py": "from joyflo import flojoy,VectorXY\nimport time\n\n@flojoy\ndef TIMER(v,params):\n    print(\"executing timer\")\n    seconds = params['seconds']\n    time.sleep(seconds)\n\n    return v"}}